from http import HTTPStatus
from typing import Any, Dict, List, Optional, Union, cast
from time import sleep
import random

import httpx

from ...client import AuthenticatedClient, Client
from ...types import Response, UNSET

{% for relative in endpoint.relative_imports %}
{{ relative }}
{% endfor %}

{% from "endpoint_macros.py.jinja" import header_params, cookie_params, query_params, json_body, multipart_body,
    arguments, client, kwargs, parse_response, docstring %}

{% set return_string = endpoint.response_type() %}
{% set return_type = endpoint.responses[0].prop.get_type_string() if endpoint.responses[0].prop.get_type_string() != "Any" else None%}
{% set parsed_responses = (endpoint.responses | length > 0) and return_string != "Any" %}

def _get_kwargs(
    {{ arguments(endpoint) | indent(4) }}
) -> Dict[str, Any]:
    url = "{}{{ endpoint.path }}".format(
        client.base_url
        {%- for parameter in endpoint.path_parameters.values() -%}
        ,{{parameter.name}}={{parameter.python_name}}
        {%- endfor -%}
    )

    headers: Dict[str, str] = client.get_headers()
    cookies: Dict[str, Any] = client.get_cookies()

    {{ header_params(endpoint) | indent(4) }}

    {{ cookie_params(endpoint) | indent(4) }}

    {{ query_params(endpoint) | indent(4) }}

    {{ json_body(endpoint) | indent(4) }}

    {{ multipart_body(endpoint) | indent(4) }}

    return {
	    "method": "{{ endpoint.method }}",
        "url": url,
        "headers": headers,
        "cookies": cookies,
        "timeout": client.get_timeout(),
        {% if endpoint.form_body_class %}
        "data": form_data.to_dict(),
        {% elif endpoint.multipart_body %}
        "files": {{ "multipart_" + endpoint.multipart_body.python_name }},
        {% elif endpoint.json_body %}
        "json": {{ "json_" + endpoint.json_body.python_name }},
        {% endif %}
        {% if endpoint.query_parameters %}
        "params": params,
        {% endif %}
    }


{% if parsed_responses %}
def _parse_response(*, response: httpx.Response) -> {{ return_type }}:
    {% for response in endpoint.responses if response.status_code >= 299 %}
    if response.status_code == {{ response.status_code }}:
        raise {{ response.prop.class_info.name }}({{ response.source }}, response.status_code)
    {% endfor %}
    {%set ok_response = endpoint.responses[0]%}
    {% import "property_templates/" + ok_response.prop.template as ok_response_prop_template %}
    {% if ok_response.prop and ok_response.prop.required_properties == [] and ok_response.prop.optional_properties == [] %}
    {{ ok_response.prop.python_name }} = {{ ok_response.prop.class_info.name }}({{ ok_response.source }})
    {% elif ok_response_prop_template.construct %}
    {{ ok_response_prop_template.construct(ok_response.prop, ok_response.source) | indent(8) }}
    {% else %}
    {{ ok_response.prop.python_name }} = None
    {% endif %}
    return {{ok_response.prop.python_name}}
{% endif %}

sleep_time = 0.05
num_retries = 3

def sync_detailed(
    {{ arguments(endpoint) | indent(4) }}
) -> {{return_type}}:
    {{ docstring(endpoint, return_type) | indent(4) }}

    kwargs = _get_kwargs(
        {{ kwargs(endpoint) }}
    )

    kwargs['headers'] = {'svix-req-id':f"{random.getrandbits(32)}", **kwargs['headers']}

    retry_count = 0
    for retry in range(num_retries):
        response = httpx.request(
                verify=client.verify_ssl,
                **kwargs,
            )
        if response.status_code >= 500 and retry < num_retries:
            retry_count +=1
            kwargs['headers']['svix-retry-count']= str(retry_count)
            sleep(sleep_time)
            sleep_time = sleep_time * 2
        else:
            break

    
    return _parse_response(response=response)

{% if parsed_responses %}
def sync(
    {{ arguments(endpoint) | indent(4) }}
) -> {{ return_type }}:
    {{ docstring(endpoint, return_type) | indent(4) }}

    return sync_detailed(
        {{ kwargs(endpoint) }}
    )
{% endif %}

async def asyncio_detailed(
    {{ arguments(endpoint) | indent(4) }}
) -> {{ return_type }}:
    {{ docstring(endpoint, return_type) | indent(4) }}

    kwargs = _get_kwargs(
        {{ kwargs(endpoint) }}
    )

    kwargs['headers'] = {'svix-req-id':f"{random.getrandbits(32)}", **kwargs['headers']}

    async with httpx.AsyncClient(verify=client.verify_ssl) as _client:
        retry_count = 0
        for retry in range(num_retries):
            response = await _client.request(
                **kwargs
            )
            if response.status_code >= 500 and retry < num_retries:
                retry_count +=1
                kwargs['headers']['svix-retry-count']= str(retry_count)
                sleep(sleep_time)
                sleep_time = sleep_time * 2
            else:
                break

    return _parse_response(response=response)

{% if parsed_responses %}
async def asyncio(
    {{ arguments(endpoint) | indent(4) }}
) -> {{ return_type }}:
    {{ docstring(endpoint, return_type) | indent(4) }}

    return (await asyncio_detailed(
        {{ kwargs(endpoint) }}
    ))
{% endif %}